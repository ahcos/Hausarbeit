package t12;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Map;


/**
 * T9Node class containing both Nodes and Leafs
 * @author FME
 *
 */
public class T9Node implements Serializable{
	
	
	/**
	 * 
	 */
	private static final long serialVersionUID = 5953901039986936999L;
	
	// parentNode to go up if needed, nodeOccurence as to how often Node occured so far, Array of child nodes childNodes, all leafs represented as Map.Entry
	private T9Node parentNode; 
	private int nodeOccurence = 0;
	private T9Node[] childNodes; 
	private  ArrayList<Map.Entry<String, Integer>> leafs;
	
	public T9Node (T9Node parentNode) {
		this.parentNode = parentNode;
		this.childNodes = new T9Node[] {null, null, null, null, null, null, null, null};
		this.leafs = null;
//		this.nodeIntegerValue = nodeIntegerValue;
		// this.leafs = new ArrayList<Map.Entry<String, Integer>>();
	}
	/**
	 * Fills die Array childNodes in the corresponding T9Node-Object
	 * @param position int - Position is bound to what kind of character the node is supposed to represent: AÃ„BC -> 0, DEF -> 1 etc.
	 * @param node	T9Node Object
	 */
	public void setChildNode (int position, T9Node node) {
		this.childNodes[position] = node;				
	}	
	
	public T9Node getChildNode (int position) {
		
		if (this.childNodes[position] == null) 
			return null;
		else 
			return this.childNodes[position];
	}
	
	public T9Node[] getChildNodeArray () {
		return this.childNodes;
	}
	
	public T9Node getParentNode () {
		return this.parentNode;
	}
	public ArrayList<Map.Entry<String, Integer>> getLeafs () {
		return this.leafs;
	}
	public void addNodeOccurence(){
		this.nodeOccurence++;
	}
	public int getNodeOccurence() {
		return this.nodeOccurence;
	}
	
	
	/**
	 * Sets leaf entries ordered by occurence in the corpus. 
	 * @param entry as generated by DataProcessing
	 * @see DataProcessing
	 */
	public void setLeafEntry (Map.Entry<String, Integer> entry) {
		// if there is no entry yet, create new List and add first entry
		if (leafs == null) {
			leafs = new ArrayList<Map.Entry<String, Integer>>();
			leafs.add(entry);
			
		}
		else {
			leafs.add(entry);
			leafs.sort((Map.Entry<String, Integer> o1, Map.Entry<String, Integer> o2) -> o2.getValue() - o1.getValue()); // descending
			
		}
	}
	@Override
	public String toString () {
		return Integer.toString(nodeOccurence);
		
	}

}
